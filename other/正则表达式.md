# 正则表达式学习

> 正则表达式（Regular Expression或Regex），是用于定义某种特定搜索模式的字符组合。正则表达式可用于匹配、查找和替换文本中的字符，进行输入数据的验证，查找英文单词的拼写错误等。

## 调试工具

  下面列出了几款优秀的在线调试工具，如果你想创建或者调试正则表达式可能会需要。个人比较偏好[Regex101](https://regex101.com/)，regex101支持在正则表达式的不同flavor之间切换、解释你的正则表达式、显示匹配信息、提供常用语法参考等功能，非常强大。

- [Regex101](https://regex101.com/)
  ![regex101](https://segmentfault.com/img/remote/1460000018489887?w=2802&h=1596)
  
- [Regexr](https://regexr.com/)
  ![Regexr](https://segmentfault.com/img/remote/1460000018489888?w=2802&h=1596)

- [Regexpal](https://www.regexpal.com/)

  ![Regexpal](https://segmentfault.com/img/remote/1460000018489889?w=2822&h=1196)



## 开始

在Javascript中，一个正则表达式以 `/` 开头和结尾，所以简单至 `/hello regexp/` 就是一个正则表达式。

### Flags（标志符或修饰符）

Flags写在结束的`/`之后，可以影响整个正则表达式的匹配行为。常见的flags有：

1. `g`：全局匹配（global）；正则表达式默认只会返回第一个匹配结果，使用标志符`g`则可以返回所有匹配
2. `i`：忽略大小写（case-insensitive）；在匹配时忽略英文字母的大小写
3. `m`：多行匹配（multiline）；将开始和结束字符（^和$）视为在多行上工作，即分别匹配每一行（由 `\n` 或 `\r` 分割）的开始和结束，而不只是只匹配整个输入字符串的最开始和最末尾处

Flags可以组合使用，如：

![flags combination](https://segmentfault.com/img/remote/1460000018489890?w=2784&h=1118)

### Character Sets（字符集合）

用于匹配字符集合中的任意一个字符，常见的字符集有：

1. `[xyz]`：匹配 `"x"`或`"y"``"z"`
2. `[^xyz]`：补集，匹配除 `"x" "y" "z"`的其他字符
3. `[a-z]`：匹配从 `"a"` 到 `"z"` 的任意字符
4. `[^a-n]`：补集，匹配除 `"a"` 到 `"n"` 的其他字符
5. `[A-Z]`：匹配从 `"A"` 到 `"Z"` 的任意字符
6. `[0-9]`：匹配从 `"0"` 到 `"9"` 的任意数字

比如匹配所有的字母和数字可以写成：`/[a-zA-Z0-9]/` 或者 `/[a-z0-9]/i`。

### Quantifiers (量词)

在实际使用中，我们常常需要匹配同一类型的字符多次，比如匹配11位的手机号，我们不可能将 `[0-9]` 写11遍，此时我们可以使用Quantifiers来实现重复匹配。

1. `{n}`：匹配 `n` 次
2. `{n,m}`：匹配 `n-m` 次
3. `{n,}`：匹配 `>=n` 次
4. `?`：匹配 `0 || 1` 次
5. `*`：匹配 `>=0` 次，等价于 `{0,}`
6. `+`：匹配 `>=1` 次，等价于 `{1,}`

### Metacharacters（元字符）

在正则表达式中有一些具有特殊含义的字母，被称为元字符，简言之，元字符就是描述字符的字符，它用于对字符表达式的内容、转换及各种操作信息进行描述。

常见的元字符有：

1. `\d`：匹配任意数字，等价于 `[0-9]`
2. `\D`：匹配任意非数字字符；`\d` 的补集
3. `\w`：匹配任意基本拉丁字母表中的字母和数字，以及下划线；等价于 `[A-Za-z0-9_]`
4. `\W`：匹配任意非基本拉丁字母表中的字母和数字，以及下划线；`\w` 的补集
5. `\s`：匹配一个空白符，包括空格、制表符、换页符、换行符和其他Unicode空格
6. `\S`：匹配一个非空白符；`\s`的补集
7. `\b`：匹配一个零宽单词边界，如一个字母与一个空格之间；例如，`/\bno/` 匹配 `"at noon"` 中的 `"no"`，`/ly\b/` 匹配 `"possibly yesterday."` 中的 `"ly"`
8. `\B`：匹配一个零宽非单词边界，如两个字母之间或两个空格之间；例如，`/\Bon/` 匹配 `"at noon"` 中的 `"on"`，`/ye\B/` 匹配 `"possibly yesterday."` 中的 `"ye"`
9. `\t`：匹配一个水平制表符（tab)
10. `\n`：匹配一个换行符（newline)
11. `\r`：匹配一个回车符（carriage return)

### Special Characters (特殊字符)

正则中存在一些特殊字符，它们不会按照字面意思进行匹配，而有特殊的意义，比如前文讲过用于量词的`?`、`*`、`+`。其他常见的特殊字符有：

1. `\`：转义字符，可以将普通字符转成特殊字符。比如 `\w`；也可以将特殊字符转成字面意思，比如 `\+` 匹配 `"+"`
2. `.`：匹配任意单个字符，但是换行符除外：`\n`, `\r`, `\u2028` 或 `\u2029`；在字符集中（`[.]`），无特殊含义，即表示 `'.'` 的字面意思
3. `|`：替换字符（alternate character），匹配 `|` 前或后的表达式。比如需要同时匹配 `"bear"` 和 `"pear"`，可以使用 `/(b|p)ear/` 或者 `/bear|pear/`；但是不能用 `/b|pear/`，该表达式只能匹配 `"b"` 和 `"pear"`
4. `^`：匹配输入的开始。比如，`/^A/` 不匹配 `"an Apple"` 中的 `"A"`，但匹配 `"An apple"` 中的 `"A"`
5. `$`：匹配输入的结尾。比如，`/t$/` 不匹配 `"eater"` 中的 `"t"`，但匹配 `"eat"` 中的 `"t"`。`^` 和 `$` 在表单验证时常需要使用，因为需要验证从开始到结尾的一个完整输入，而不是匹配输入中的某一段

### Groups（分组）

1. `(xyz)`：捕获分组（Capturing Group），匹配并捕获匹配项；例如，`/(foo)/` 匹配且捕获 `"foo bar."` 中的 `"foo"`。被匹配的子字符串可以在结果数组的元素 [1], ..., [n] 中找到，或在被定义的 RegExp 对象的属性 $1, ..., $9 中找到
2. `(?:xyz)`：非捕获分组（Non-capturing Group），匹配但不会捕获匹配项；匹配项不能再次被访问到
3. `\n`：`n` 是一个正整数，表示反向引用（back reference），指向正则表达式中第n个括号（从左开始数）中匹配的子字符串；例如，`/apple(,)\sorange\1/` 匹配 `"apple, orange, cherry, peach."` 中的 `"apple,orange,"`

### Assertion（断言）

1. `x(?=y)`：仅匹配被`y`跟随的`x`；例如，`/bruce(?=wayne)/`，如果`"bruce"`后面跟着`wayne`，则匹配之。`/bruce(?=wayne|banner)/` ，如果`"bruce"`后面跟着`"wayne"`或者`banner`，则匹配之。但是，`"wayne"` 和 `"banner"` 都不会在匹配结果中出现
2. `x(?!y)`：仅匹配不被`y`跟随的`x`；例如，`/\d+(?!\.)/` 只会匹配不被 `"."` 跟随的数字。

```
/\d+(?!\.)/.exec('3.141')` 匹配 `"141"`，而不是 `"3.141"
```

## 应用

上面罗列出了这么多正则表达式的语法和规则，可以在一定程度上帮助我们分析和理解一段正则表达式的作用，但是如何将这些规则组合并创造出有特定作用的表达式还需要我们自己多加练习，下面举几个例子来说明运用这些规则。

### 1. 匹配手机号码

我们先从比较简单的匹配手机号码开始。目前国内的手机号码是`1(3/4/5/7/8)`开头的11位数字，因此手机号码的正则可以分解为以下几部分：

1. 以 `1` 开头：`/^1/`
2. 第2位为`3、4、5、7、8`中的一个：`/[34578]/` 或 `/(3|4|5|7|8)/`
3. 剩余3-11位均为数字，并以数字结尾：`/\d{9}$/`

组合起来即为 `/^1[34578]\d{9}$/` 或 `/^1(3|4|5|7|8)\d{9}$/`，因为使用捕获括号存在性能损失，所以推荐使用第一种写法。

### 2. 匹配电子邮件

标准的电子邮件组成为 `<yourname>@<domain>.<extension><optional-extension>`，

每部分的格式标准为（进行了相应的简化，主要为展示如何书写正则）：

1. yourname：任意英文字母（a-z/A-Z）、数字（0-9）、下划线（_）、英文句点（.）、连字符（-），长度大于0
2. domain：任意英文字母（a-z/A-Z）、数字（0-9）、连字符（-），长度大于0
3. extension：任意英文字母（a-z/A-Z），长度2-8
4. optional-extension：`"."`开头，后面跟任意英文字母（a-z/A-Z），长度2-8，可选

每部分的正则表达式为：

1. yourname：`/[a-z\d._-]+/`
2. domain：`/[a-z\d-]+/`
3. extension： `/[a-z]{2,8}/`
4. optional-extension：`/(\.[a-z]{2,8})?/`

组合起来形成最后的正则表达式：`/^([a-z\d._-]+)@([a-z\d-]+)\.([a-z]{2,8})(\.[a-z]{2,8})?$/`；为了增加可读性可以将每部分用`"()"`包起来，并不要忘记起始和结束符 `^$`。